Project 3a in list Projects and Assignments
Due Date
Apr 7 at 11:59 Pm

Description
Team project
Learning objectives
    More advanced Scala
    An understanding of
        algebraic data types as initial F-algebras
        representation of programs as recursive data structures (trees)
        program interpretation (evaluation) as recursive functions on programs
        limitations of catamorphisms

Functional requirements
In this project, you will use Scala to implement an interpreter for a simple untyped lambda calculus
(the computational model underlying functional programming languages such as Haskell). This amounts to an almost
 verbatim implementation of the calculus described here (except that we do not yet have a list type).

Abstract Syntax
Specifically, you will define an endofunctor that includes the variants for arithmetic expressions along with
the following functional language constructs:

    lambda x . e: anonymous function, that is, a designated formal argument x along with a function body in which x
occurs zero or more times
    x: variable (presumably occurring in an expression with ancestor that is a lambda expression introducing x as a
formal argument)
    e1 e2: function application, that is, an expression (presumably representing a function) followed by
another expression (presumably representing an actual argument)
    if c then e1 else e2: conditional
We will worry about concrete syntax (strings that would be parsed into an equivalent abstract syntax tree)
in a later phase of this project.

Semantics
The semantic domain (values) is a subdomain of the abstract syntactic domain consisting only of

    integer constants
    function closures
Next, you will define a function for evaluating expressions represented using the abstract syntax defined above
using normal-order evaluation (a non-strict evaluation strategy). This function takes an expression that follows
the abstract syntax defined above and reduces it to a value from the semantic domain.

To evaluate an arithmetic expression, simply port the Scala example. An arithmetic expression involving
non-arithmetic values is an error.
    An anonymous function definition evaluates to itself.
    An** (unbound) variable by itself is an error.
A function application is evaluated as follows (this is where the evaluation order is decided):
1**.The first expression is evaluated. (If it the result is not a function closure, lambda x . b, then there is an error.)
2**Beta substitution is performed to substitute the second expression (without evaluating it) for every free
occurrence of x in b.
3.The resulting function body (after the substitution) is evaluated.

A conditional is evaluated as follows. (Note that it is non-strict in e1 and e2, otherwise it would defeat the purpose.)
1.The condition is evaluated.
2.If the result the integer constant 0, then the result is the result of evaluating e2.
3.Otherwise, if the condition is non-0, the result is the result of evaluating e1.
In particular, you should implement a separate auxiliary function for beta substitution. Then use this
function in the evaluation of function application.

Examples
eval(Const(3)) -> Const(3)
eval(Var("x")) -> error
eval(Fun("x", Plus(Const(7), Var("x"))))
  -> Fun("x", Plus(Const(7), Var("x")))
eval(App(Fun("x", Plus(Const(7), Var("x"))), Const(3)))
  -> Const(10)
eval(App(Var("x"), Const(3)) -> error
eval(If(Const(7), Const(3), Const(4))) -> Const(3)
eval(If(Const(0), Const(3), Const(4))) -> Const(4)
eval(If(Fun("x", Var("x")), Const(3), Const(4))) -> Const(3)
eval(If(Fun("x", Var("y")), Const(3), Const(4))) -> Const(3)
val Y = // you'll define it yourself as in the handout!
eval(App(App(Y, Fun("f", Fun("n", If(Var("n"),
  Times(Var("n"), App(Var("f"), Minus(Var("n"), Const(1)))), Const(1))))),
  Const(5)))
  -> Const(120)

Nonfunctional requirements
Start with this example.
Add the additional case classes to the endofunctor.
Define eval as a recursive function on the initial F-algebra.
Why can eval not be defined as a catamorphism (using a suitable F-algebra)?
Think about a good way to represent evaluation errors.
First identify the different kinds of evaluation errors.
Hint: look for a Scala type similar to Option that allows you to return a successful result but also to describe failure better than None.
Because these errors arise during evaluation of programs in our calculus, there is no good way to proceed beyond the first error.
Create a test suite that includes at least the examples above.
Submission
Please post to the Facebook group or send email when your project is ready to grade.

Grading criteria
TODO

What's next
3b: addition of cons cells
3c: type checker
3d: parser
Additional Reading
John McCarthy et al, LISP 1.5 Reference Manual, MIT Press, 1962
Are “normal order” and “call-by-name” the same thing?


